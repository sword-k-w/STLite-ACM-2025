# 二项堆复杂度分析

author: 王健豪

reference: https://www.cnblogs.com/luanxm/p/10847925.html

## 定义及性质

### 二项树

我们归纳地定义二项树：

- 首先，二项树是一棵有根有序树。

- 二项树 $T_0$ 是只有根节点的树。

- 二项树 $T_n(n\in \mathbb{N}_+)$ 的根有 $n$ 个子树，这 $n$ 个子树分别是 $T_0,\cdots,T_{n-1}$ 。

一些比较显然，但比较重要的性质：

1. 二项树 $T_n(n\in \mathbb{N}_+)$ 去除掉最后一个儿子 $(T_{n-1})$ 后剩下的树正好是 $T_{n-1}$ 。

2. 二项树 $T_n$ 有 $2^n$ 个节点。

性质1提供了合并两个相同秩（我们称 $n$ 为二项树的秩）的二项树的合理性与可行性，性质2则为二项树的复杂度分析提供了重要依据。

### 二项堆

二项堆（以大根堆为例）是一个二项树森林，并满足以下条件：

- 任何一个二项树都是大根堆（如果一个节点 $u$ 有父节点 $f$，那么 $val_f\geq val_u$）。

- 不存在秩相同的二项树。

为了方便，通常实现的时候会使用一个单向链表将二项树的根串连起来，并且是由秩小的二项树指向秩大的二项树。

不难发现，一个有 $N=2^{c_0}+\cdots+2^{c_k}(c_0<\cdots<c_k)$ 个节点的二项堆，它其中恰好包含 $T_{c_0},\cdots,T_{c_k}$，而自然数的二进制表示是唯一的，所以任何给定的 $N$ ，二项堆的形态是确定的。

我们并没有规定所有二项树的最大值的位置，所以还需要用一个最大值指针指向所有根中 $val$ 最大的一个。

## 操作

### 合并

合并操作是二项堆最核心的操作，分为根链归并和同秩合并两个部分。

#### 根链归并

由于链表中二项树的秩是递增的，所以合并两个二项堆时，用类似归并排序的操作可以线性地将根链简单的归并起来，这时候根链上的秩仍是不增的，但会存在有相同秩的二项树的情况，所以进入下一步骤。

#### 同秩合并

我们把这个过程与二进制数加法类比，在考虑每一位的时候有几种情况，我们假设当前所在的二项树的秩为 $k$，分别讨论：

- 下一个二项树的秩大于 $k$ ，类似 "$1+0$"，所以不用处理。

- 下一个二项树的秩等于 $k$ ，但再下一个二项树的秩大于 $k$ ，类似于 "$1+1$"，比较一下两个根的 $val$ ，确定父子关系，并利用性质2合并这两棵树。

- 下一个二项树的秩等于 $k$ ，再下一个二项树的秩也等于 $k$ ，类似于 "$1+1$" ，但前一位在做加法的时候进位了（之前讨论情况中的 "$1$" 也有可能是进位来的），这时候只需要把后两个二项树合并一下就行了。

最后需要再维护一下最大值指针。

#### 复杂度

由于 $n$ 的二进制位最多有 $\mathcal{O}(\log n)$ 个，而合并操作的时候只会访问两个根链上的节点常数次，所以合并操作的最坏复杂度是 $\mathcal{O}(\log n)$

### 插入

把插入节点当成一棵只有一个 $T_0$ 的二项堆，合并入原堆就好了，最坏复杂度 $\mathcal{O}(\log n)$ 。值得注意的是，如果通过插入操作构造一个大小为 $n$ 的二项堆（中途没有删除堆顶操作）时，复杂度是均摊 $\mathcal{O}(1)$ 的，也就是总复杂度是 $\mathcal{O}(n)$ 的。也很容易证明，不妨设 $n=2^m$ (如果不是，$[n,2n)$中至少有一个满足) ，记 $l(k)$ 为 $k$ 二进制下的位数。那么根据合并操作的分析，总操作次数是 $C(\sum_{i=1}^{n}l(i)+n)$。考虑到第 $l(k)=t$ 的 $k$ 一共只有 $\binom{m + 1}{t}$ 个，所以 $\sum_{i=1}^{n}l(i)<2^{m+1}=2n$ ，所以总复杂度是 $\mathcal{O}(n)$ 的。

### 取最大值

直接调用获取最大值指针的值即可，$\mathcal{O}(1)$ 。

### 删除堆顶

把最大值指针指向的节点删除后，其所在的二项树剩下了 $\mathcal{O}(\log n)$ 个二项树，并且它们也是按秩从小到大链接的（在合并操作的时候也要维护兄弟之间的链接），把这些二项树和删除剩下的二项树森林合并即可。复杂度同合并操作，最坏 $\mathcal{O}(\log n)$ 。
